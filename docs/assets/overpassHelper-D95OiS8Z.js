const t=["https://overpass-api.de/api/interpreter","https://overpass.kumi.systems/api/interpreter","https://overpass.openstreetmap.ru/api/interpreter"];async function e(e,r={}){const{timeout:o=25,maxRetries:n=3,retryDelay:a=2e3,endpoints:s=t,signal:i}=r,c=[];for(const t of s)for(let r=1;r<=n;r++)try{const r=new AbortController,n=setTimeout(()=>r.abort(),1e3*o);i&&i.addEventListener("abort",()=>r.abort());const a=`${t}?data=${encodeURIComponent(e)}`,s=await fetch(a,{method:"GET",signal:r.signal,headers:{Accept:"application/json"}});if(clearTimeout(n),i&&i.removeEventListener("abort",()=>r.abort()),!s.ok){const t=await s.text().catch(()=>"Unknown error");throw 504===s.status||502===s.status?new Error(`Gateway timeout (${s.status})`):429===s.status?new Error("Rate limit exceeded"):400===s.status?new Error(`Bad request: ${t.substring(0,200)}`):new Error(`HTTP ${s.status}: ${t.substring(0,200)}`)}const c=await s.json();if(c.remark,!c.elements||!Array.isArray(c.elements))throw new Error("Invalid response format: missing elements array");return c}catch(p){const e=p instanceof Error?p.message:String(p);if("AbortError"===p.name){c.push({endpoint:t,error:"Timeout"});break}r<n?await new Promise(t=>setTimeout(t,a)):c.push({endpoint:t,error:e})}const m=c.map(t=>`${t.endpoint}: ${t.error}`).join("; ");throw new Error(`All Overpass endpoints failed after ${n} attempts each. Errors: ${m}`)}function r(t,e=25){return`\n    [out:json][timeout:${e}];\n    (\n      way["highway"~"^(primary|secondary|tertiary|residential|unclassified|service|living_street|track)$"](bbox:${t});\n      way["highway"~"^(motorway|trunk)$"](bbox:${t});\n      way["highway"="cycleway"]["motor_vehicle"!="no"](bbox:${t});\n      way["railway"="tram"](bbox:${t});\n      way["access"~"^(yes|permissive)$"]["highway"](bbox:${t});\n    );\n    (._;>;);\n    out geom;\n  `.trim()}async function o(e,r={}){const{timeout:o=25,maxRetries:n=2,retryDelay:a=3e3,endpoints:s=[t[0]],signal:i}=r,c=[];for(const t of s)for(let r=1;r<=n;r++)try{const r=new AbortController,n=setTimeout(()=>r.abort(),1e3*o);i&&i.addEventListener("abort",()=>r.abort());const a=await fetch(t,{method:"POST",body:e,headers:{"Content-Type":"text/plain",Accept:"application/json"},signal:r.signal});if(clearTimeout(n),i&&i.removeEventListener("abort",()=>r.abort()),!a.ok){const t=await a.text().catch(()=>"Unknown error");throw new Error(`HTTP ${a.status}: ${t.substring(0,200)}`)}const s=await a.json();if(!s.elements||!Array.isArray(s.elements))throw new Error("Invalid response format");return s}catch(m){const e=m instanceof Error?m.message:String(m);r<n?await new Promise(t=>setTimeout(t,a)):c.push({endpoint:t,error:e})}throw new Error(`All POST endpoints failed. Errors: ${c.map(t=>t.error).join("; ")}`)}export{r as createThreatAnalysisQuery,o as fetchOverpassPOSTWithFallback,e as fetchOverpassWithFallback};
